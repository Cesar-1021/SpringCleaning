<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dirty Laundry</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.4.0/p5.js"></script>
    <style>
        body {
            margin: 0;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        #returnButton {
            display: none;
            position: fixed;
            top: 80%;
            left: 50%;
            transform: translate(-50%);
            padding: 2vmin;
            font-size: 5vmin;
            color: white;
            background-color: black;
            border: none;
            border-radius: 3vmin;
            cursor: pointer;
            z-index: 1000;
        }

        #returnButton:hover {
            background-color: pink;
        }
    </style>
</head>

<body>
    <button id="returnButton">Return to Room</button>
    <script>
        var hamperCheck = localStorage.getItem('hamperCheck');

        let court;
        let sock, sockImg, hamper, hamperImg, girl, girlEmpty, girlHolding;
        const num = 5;

        let gravity = 0.4;
        let isAiming = false;
        let aimPower = 0;
        let aimAngle = 0;
        let maxPower = 20;

        let refScale;
        let width;
        let height;
        let inAir = false;

        // Preload all images
        function preload() {
            court = loadImage('sprites/miniGames/court.png');
            sockImg = loadImage("sprites/enemies/sock.png");
            hamperImg = loadImage("sprites/miniGames/hamperCourt.png");
            girlEmpty = loadImage("sprites/miniGames/hamperShot.png");
            girlHolding = loadImage("sprites/miniGames/hamperSock.png");
        }

        function setup() {
            frameRate(60);

            refScale = Math.min(windowWidth / court.width, windowHeight / court.height);

            let canvasX = (windowWidth / 2) - (court.width / 2) * refScale;
            let canvasY = (windowHeight / 2) - (court.height / 2) * refScale;
            width = court.width * refScale;
            height = court.height * refScale;

            canvas = createCanvas(width, height);
            canvas.position(canvasX, canvasY);

            calculatePositions()
            mouseX = windowWidth / 2;
            mouseY = windowHeight / 2;
        }

        function windowResized() {
            refScale = Math.min(windowWidth / court.width, windowHeight / court.height);
            let canvasX = (windowWidth / 2) - (court.width / 2) * refScale;
            let canvasY = (windowHeight / 2) - (court.height / 2) * refScale;
            width = court.width * refScale;
            height = court.height * refScale;

            resizeCanvas(width, height);
            calculatePositions()
            canvas.position(canvasX, canvasY);
        }

        function calculatePositions() {
            hamper = {
                left: width - 680 * refScale,
                right: width - 680 * refScale + hamperImg.width / 2 * refScale,
                top: 270 * refScale,
                bottom: 270 * refScale + hamperImg.height / 2 * refScale,
                width: hamperImg.width / 2 * refScale,
                height: hamperImg.height / 2 * refScale
            };

            girl = {
                x: 250 * refScale,
                y: height - 470 * refScale,
                width: girlEmpty.width / 2 * refScale,
                height: girlEmpty.height / 2 * refScale
            };

            sock = {
                left: 250 * refScale,
                right: 250 * refScale + sockImg.width / 5 * refScale,
                top: height - 220 * refScale,
                bottom: height - 220 * refScale + sockImg.height / 5 * refScale,
                width: sockImg.width / 5 * refScale,
                height: sockImg.height / 5 * refScale,
                velocityX: 0,
                velocityY: 0,
            };
        }

        function draw() {
            background(court); // set the background every frame

            // Update sock position based on its velocity
            sock.left += sock.velocityX;
            sock.right = sock.left + sock.width;
            sock.top += sock.velocityY;
            sock.bottom = sock.top + sock.height;

            // Apply gravity to the sock's vertical movement
            sock.velocityY += gravity;

            // Collision detection between the sock and the ground
            if (sock.top > height - 250 * refScale) {
                // Make the sock bounce a bit before stopping
                if (abs(sock.velocityX) > 0.1 && abs(sock.velocityY) > 0.1) {
                    sock.velocityY = -sock.velocityY / 2;
                    sock.velocityX = sock.velocityX / 2;
                }
                // Stop the sock completely
                else {
                    sock.top = height - 250 * refScale;
                    sock.velocityY = 0;
                    sock.velocityX = 0;
                    inAir = false;
                }
            }

            // Check if the sock is off screen
            if (!onScreen(sock)) {
                // sock is on right of screen
                if (sock.x > width / 2) {
                    sock.x = 2;
                }
                // sock is on left of screen
                else {
                    sock.x = width - 2;
                }
                sock.velocityX = -sock.velocityX * .9;
            }

            if (sock.bottom > hamper.top + sock.width / 2 && sock.top < hamper.bottom // within top and bottom
            ) {
                // Check if sock hits left side of hamper
                if (sock.right > hamper.left && // right of sock inside hamper
                    sock.left < hamper.left && // left of sock outside hamper
                    sock.velocityX > 0) { // moving right
                    sock.velocityX = -sock.velocityX * .9; // negate x direction
                    sock.velocityY += 0.5;
                }
                // Check if sock hits right side of hamper
                else if (sock.left < hamper.right && // left of sock inside hamper
                    sock.right > hamper.right && // Right of sock outside hamper
                    sock.velocityX < 0) { // moving left
                    sock.velocityX = -sock.velocityX * .9; // negate x direction
                    sock.velocityY += 0.5;
                }
            }
            if (sock.right - sock.width / 2 > hamper.left && sock.left + sock.width / 2 < hamper.right // within right and left
            ) {
                // Check if sock hits bottom of hamper
                if (sock.top < hamper.bottom && // top of sock inside hamper
                    sock.bottom > hamper.bottom && // bottom of sock outside hamper
                    sock.velocityY < 0) { // moving up
                    sock.velocityY = -sock.velocityY * .9;
                }
                // Check if sock lands in hamper
                else if (sock.bottom - sock.height / 2 > hamper.top && // half of sock inside hamper
                    sock.bottom < hamper.bottom &&
                    sock.velocityY > 0) { // checks if the sock is falling down into the hamper
                    resetSock();
                }
            }

            // Draw aiming line if aiming
            if (isAiming) {
                girl.x = sock.left;
                image(girlHolding, girl.x - girl.width / 3, girl.y, girl.width, girl.height);
                drawTrajectory();
            }
            else {
                image(sockImg, sock.left, sock.top, sock.width, sock.height);
            }
            if (inAir) {
                image(girlEmpty, girl.x - girl.width / 3, girl.y, girl.width, girl.height);
            }

            image(hamperImg, hamper.left, hamper.top, hamper.width, hamper.height);

            if (hamperCheck === '0') {
                document.getElementById("returnButton").style.display = "block";
            } else {

            }

        }

        // Function to draw the trajectory as a dotted line
        function drawTrajectory() {
            let steps = 50; // Number of steps in the trajectory
            let timeStep = 1; // Time step for simulation
            let posX = sock.left + sock.width / 2, posY = sock.top + sock.height / 2;
            let velX = max(min((mouseX - sock.left - sock.width / 2) * 0.1, maxPower), -maxPower);
            let velY = max((mouseY - sock.top - sock.height / 2) * 0.1, -maxPower);

            stroke(255, 255, 255);
            strokeWeight(4);
            for (let i = 4; i < steps; i++) {
                let oldX = posX, oldY = posY;
                velY += gravity * timeStep; // Apply gravity
                posX += velX * timeStep;
                posY += velY * timeStep;

                // Draw a dot at the current position
                point(posX, posY);
            }
        }

        // Check if the sock is still on the screen
        function onScreen(sock) {
            return sock.left >= 0 && sock.right <= width;
        }

        // Reset sock to starting position and make it visible
        function resetSock() {
            sock.left = 250 * refScale;
            sock.top = height - 220 * refScale;
            sock.velocityX = 0;
            sock.velocityY = 0;
            sock.visible = true; // Ensure sock is visible when reset
        }

        // Mouse functions for aiming and shooting
        function mousePressed() {
            if (!inAir) {
                isAiming = true;
            }
        }

        function mouseReleased() {
            if (isAiming) {
                let aimVector = createVector(mouseX - sock.left - sock.width / 2, mouseY - sock.top - sock.height / 2);
                sock.velocityX = max(min(aimVector.x * 0.1, maxPower), -maxPower);
                sock.velocityY = max(aimVector.y * 0.1, -maxPower);
            }
            inAir = true;
            isAiming = false;
        }

        document.addEventListener("DOMContentLoaded", function () {
            var returnButton = document.getElementById('returnButton');
            returnButton.addEventListener('click', function () {
                window.location.href = 'room.html';
            });
        });

    </script>
</body>

</html>